<!DOCTYPE html><html lang="ko"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Airbnb가 LLM으로 GraphQL Mock 데이터 생성 자동화한 방법</title>    <link rel="preconnect" href="https://fonts.googleapis.com">    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>    <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">    <style>        @import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css");                * {            margin: 0;            padding: 0;            box-sizing: border-box;        }                body {            font-family: "Pretendard Variable", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;            background: #faf8f5;            color: #2d2d2d;            line-height: 1.7;            padding: 20px;            font-size: 16px;        }                .container {            max-width: 850px;            margin: 0 auto;            background: #ffffff;            border-radius: 16px;            overflow: hidden;            box-shadow: 0 4px 20px rgba(201, 69, 31, 0.08);            animation: fade-in 0.6s ease;        }                @keyframes fade-in {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .header {            background: linear-gradient(135deg, #FF5A5F 0%, #FC636B 100%);            padding: 48px 40px;            color: #ffffff;        }                .header-label {            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            letter-spacing: 1.5px;            opacity: 0.9;            margin-bottom: 12px;            text-transform: uppercase;        }                .header h1 {            font-family: 'Fraunces', serif;            font-size: 36px;            font-weight: 700;            line-height: 1.3;            margin-bottom: 16px;        }                .header-meta {            font-size: 14px;            opacity: 0.85;            font-weight: 500;        }                .content {            padding: 48px 40px;        }                .intro {            font-size: 18px;            line-height: 1.8;            color: #3d3d3d;            margin-bottom: 40px;            padding-bottom: 32px;            border-bottom: 2px solid #f0ebe5;            animation: fade-slide-up 0.6s ease 0.2s both;        }                .intro p {            margin-bottom: 16px;        }                .intro p:last-child {            margin-bottom: 0;        }                .intro strong {            color: #FF5A5F;            font-weight: 600;        }                .intro ul {            list-style: none;            padding-left: 0;            margin: 20px 0;        }                .intro ul li {            padding-left: 28px;            margin-bottom: 10px;            position: relative;            line-height: 1.7;        }                .intro ul li::before {            content: "•";            position: absolute;            left: 0;            color: #FF5A5F;            font-weight: 600;            font-size: 20px;        }                @keyframes fade-slide-up {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .section {            margin-bottom: 40px;            animation: fade-slide-up 0.6s ease both;        }                .section:nth-child(2) { animation-delay: 0.3s; }        .section:nth-child(3) { animation-delay: 0.4s; }        .section:nth-child(4) { animation-delay: 0.5s; }        .section:nth-child(5) { animation-delay: 0.6s; }        .section:nth-child(6) { animation-delay: 0.7s; }                .section-title {            font-family: 'Fraunces', serif;            font-size: 24px;            font-weight: 700;            color: #FF5A5F;            margin-bottom: 20px;            display: flex;            align-items: center;            gap: 12px;        }                .section-emoji {            font-size: 28px;        }                .section-content {            font-size: 16px;            line-height: 1.8;            color: #3d3d3d;        }                .section-content p {            margin-bottom: 16px;        }                .section-content p:last-child {            margin-bottom: 0;        }                .highlight-box {            background: #fff9f5;            border-left: 4px solid #FF5A5F;            padding: 20px 24px;            margin: 20px 0;            border-radius: 0 8px 8px 0;        }                .highlight-box p {            margin-bottom: 12px;            font-size: 15px;        }                .highlight-box p:last-child {            margin-bottom: 0;        }                .highlight-box strong {            color: #FF5A5F;        }                .code-box {            background: #2d2d2d;            color: #f0ebe5;            padding: 20px 24px;            border-radius: 8px;            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            line-height: 1.6;            margin: 20px 0;            overflow-x: auto;        }                .code-box code {            color: #6dd4c4;        }                .phase-box {            background: #ffffff;            border: 2px solid #FF5A5F;            padding: 24px;            margin: 20px 0;            border-radius: 12px;        }                .phase-title {            font-family: 'Fraunces', serif;            font-size: 20px;            font-weight: 700;            color: #FF5A5F;            margin-bottom: 16px;            display: flex;            align-items: center;            gap: 10px;        }                .phase-content {            font-size: 15px;            line-height: 1.7;            color: #3d3d3d;        }                .phase-content p {            margin-bottom: 12px;        }                .phase-content p:last-child {            margin-bottom: 0;        }                .metric-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 16px;            margin: 24px 0;        }                .metric-card {            background: #faf8f5;            padding: 20px;            border-radius: 12px;            border: 1px solid #f0ebe5;            transition: all 0.3s ease;        }                .metric-card:hover {            transform: translateY(-4px);            box-shadow: 0 6px 20px rgba(0, 177, 79, 0.12);        }                .metric-label {            font-family: 'JetBrains Mono', monospace;            font-size: 12px;            color: #8d6e5f;            margin-bottom: 8px;            text-transform: uppercase;            letter-spacing: 0.5px;        }                .metric-value {            font-family: 'Fraunces', serif;            font-size: 28px;            font-weight: 700;            color: #FF5A5F;            margin-bottom: 8px;        }                .metric-desc {            font-size: 14px;            color: #5d5d5d;            line-height: 1.5;        }                .bullet-list {            list-style: none;            padding-left: 0;            margin: 16px 0;        }                .bullet-list li {            padding-left: 32px;            margin-bottom: 12px;            position: relative;            line-height: 1.7;        }                .bullet-list li::before {            content: "→";            position: absolute;            left: 0;            color: #FF5A5F;            font-weight: 600;            font-size: 18px;        }                .stage-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 12px;            margin: 24px 0;        }                .stage-card {            background: #fff9f5;            border: 1px solid #FF5A5F;            padding: 16px;            border-radius: 8px;            text-align: center;        }                .stage-number {            font-family: 'Fraunces', serif;            font-size: 32px;            font-weight: 700;            color: #FF5A5F;            margin-bottom: 8px;        }                .stage-name {            font-weight: 700;            color: #2d2d2d;            margin-bottom: 8px;            font-size: 14px;        }                .stage-desc {            font-size: 12px;            color: #5d5d5d;            line-height: 1.5;        }                .cta-box {            background: linear-gradient(135deg, #FF5A5F 0%, #FC636B 100%);            color: #ffffff;            padding: 32px;            border-radius: 12px;            margin-top: 40px;            text-align: center;        }                .cta-box h3 {            font-family: 'Fraunces', serif;            font-size: 22px;            margin-bottom: 16px;        }                .cta-box p {            font-size: 15px;            line-height: 1.7;            opacity: 0.95;            margin-bottom: 20px;        }                .cta-button {            display: inline-block;            background: #ffffff;            color: #FF5A5F;            padding: 14px 32px;            border-radius: 8px;            text-decoration: none;            font-weight: 600;            font-size: 15px;            transition: all 0.3s ease;        }                .cta-button:hover {            transform: translateY(-2px);            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);        }                .footer {            background: #faf8f5;            padding: 32px 40px;            text-align: center;            font-size: 14px;            color: #8d6e5f;            border-top: 1px solid #f0ebe5;        }                .footer p {            margin-bottom: 8px;        }                .footer a {            color: #FF5A5F;            text-decoration: none;            font-weight: 600;        }                .footer a:hover {            text-decoration: underline;        }                @media (max-width: 768px) {            body {                padding: 12px;            }                        .header {                padding: 32px 24px;            }                        .header h1 {                font-size: 28px;            }                        .content {                padding: 32px 24px;            }                        .intro {                font-size: 16px;            }                        .section-title {                font-size: 20px;            }                        .metric-grid, .stage-grid {                grid-template-columns: 1fr;            }                        .footer {                padding: 24px;            }        }    </style></head><body>    <div class="container">        <!-- 헤더 -->        <div class="header">            <div class="header-label">Airbnb Engineering</div>            <h1>Airbnb가 LLM으로 GraphQL Mock 데이터 생성 자동화한 방법</h1>            <div class="header-meta">@generateMock 하나로 700+ 목 데이터 수동 작업 제거</div>        </div>                <div class="content">            <!-- 도입부 -->            <div class="intro">                <p>새로운 기능을 개발할 때, 서버 개발이 끝나기도 전에 클라이언트에서 UI를 만들고 테스트해야 하는 상황, 자주 겪으시죠? 손으로 GraphQL Mock 데이터를 일일이 작성하고, 쿼리가 바뀔 때마다 수정하고, 또 다른 기능에 맞춰 다시 만드는 지루한 작업에 시간을 낭비해본 경험이 있다면 그 고통을 잘 아실 겁니다. 표면적으로는 멀쩡해 보여도 '이거 목 데이터구나' 싶은, 뭔가 현실성이 떨어지는 값들 때문에 데모조차 망설여지는 순간도 있었을 거예요.</p>                                <p>랜덤 값 생성기나 필드별 스터빙 도구가 있긴 하지만, 현실적이고 의미 있는 데이터를 만들기 위한 도메인 지식이 부족합니다. 결국, 개발자는 핵심 기능보다는 데이터 생성에 더 많은 시간을 할애하게 되죠. Airbnb는 이 문제를 근본적으로 해결하기 위해 LLM과 GraphQL 인프라를 결합하는 새로운 접근 방식을 택했습니다.</p>                                <p>이 글에서는 Airbnb가 어떻게 LLM과 새로운 GraphQL 디렉티브를 활용하여 이런 고질적인 문제를 해결하고, 개발 생산성을 혁신적으로 끌어올렸는지 자세히 정리해 봅니다. 특히 다음 내용을 중심으로 살펴볼 거예요.</p>                                <ul>                    <li>손으로 작성하던 GraphQL Mock 데이터가 사라진 이유 - 수동 작업의 3가지 고통과 자동화 필요성</li>                    <li><code>@generateMock</code>: 디렉티브 하나로 디자인 목업과 일치하는 현실적인 데이터 만드는 법 - <code>designURL</code>, <code>hints</code> 활용</li>                    <li>LLM + GraphQL 검증으로 타입 안전성 보장하는 구조 - Gemini 2.5 Pro와 <code>graphqlSync</code>의 시너지</li>                    <li><code>@respondWithMock</code>: 서버 없이 프론트 먼저 완성하는 비결 - 로컬 목 데이터로 개발 흐름 끊기지 않게</li>                    <li>자동 싱크: 쿼리 변경 시 목 데이터도 자동 업데이트하는 시스템 - 해시 기반 버전 관리와 LLM 보정</li>                </ul>            </div>                        <!-- 본문 섹션 1 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">😩</span>                    손으로 만드는 Mock 데이터, 왜 이렇게 고통스러울까요?                </h2>                <div class="section-content">                    <p>Airbnb 팀이 엔지니어 설문과 인터뷰를 통해 정리한 핵심 문제들입니다. 이 문제들은 비단 Airbnb만의 것이 아니라, 업계 전반의 GraphQL 개발자들이 공통적으로 겪는 고질적인 페인 포인트이기도 합니다.</p>                    <div class="highlight-box">                        <p><strong>1. 수동 작성에 시간이 너무 많이 걸린다</strong></p>                        <p>GraphQL 쿼리는 쉽게 수백 줄로 늘어납니다. 목 데이터를 JSON으로 손으로 작성하거나, 서버 응답을 복사-붙여넣기하고 수정하는 작업은 극도로 지루하죠. 데모나 스냅샷 테스트에 쓸 현실적인 데이터를 만들려면 시간이 더 걸리고, 미묘한 실수가 자주 생깁니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>2. 서버 없이 프로토타입 만들기가 어렵다</strong></p>                        <p>보통 서버와 클라이언트 엔지니어는 GraphQL 스키마를 먼저 확정하고 각자 작업을 시작합니다. 문제는 클라이언트 엔지니어가 서버 구현이 완료될 때까지 UI 테스트를 할 수 없다는 점이죠. 데이터를 하드코딩하거나, 프록시를 쓰거나, 네트워크 레이어를 해킹하는 방식으로 임시방편을 마련하곤 합니다. 이 모든 과정이 시간 낭비로 이어집니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>3. 시간이 지나면 목 데이터와 쿼리가 어긋난다</strong></p>                        <p>대부분의 목은 손으로 작성되기 때문에 쿼리나 스키마와 느슨하게 연결될 수밖에 없습니다. 새로운 필드가 추가되면 목 데이터를 수동으로 업데이트해야 하는데, 이를 놓치는 경우가 많죠. 결국 목 데이터는 실제 프로덕션과 점점 멀어지며 테스트 품질이 저하됩니다. 기존의 랜덤 값 생성기나 필드별 리졸버는 '도메인 컨텍스트' 부족으로 현실적인 데이터를 제공하지 못했습니다.</p>                    </div>                </div>            </div>                        <!-- 본문 섹션 2 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">✨</span>                    디렉티브 하나로 디자인과 찰떡인 Mock 데이터 만들기                </h2>                <div class="section-content">                    <p>Airbnb의 핵심 아이디어는 바로 <code>@generateMock</code>이라는 새로운 클라이언트 GraphQL 디렉티브입니다. 이 디렉티브를 쿼리, 프래그먼트, 또는 특정 필드에 추가하기만 하면 LLM이 알아서 목 데이터를 생성해 줍니다.</p>                    <div class="code-box">                        <code>query InboxQuery @generateMock(  id: "mixed_status_indicators",  designURL: "figma://node-id",  hints: "Include travel entries for Barcelona, Paris, and Kyoto.") {  inbox {    threads { id }  }}</code>                    </div>                    <p><code>@generateMock</code>은 몇 가지 유용한 옵션을 제공합니다:</p>                    <ul class="bullet-list">                        <li><strong><code>id</code></strong>: 목 데이터의 고유 식별자로, 여러 개의 목 데이터를 생성할 때 유용합니다.</li>                        <li><strong><code>hints</code></strong>: "바르셀로나, 파리, 교토 여행 항목을 포함해줘"처럼 LLM에게 더 현실적인 데이터를 만들도록 지시하는 추가 컨텍스트입니다.</li>                        <li><strong><code>designURL</code></strong>: 해당 데이터가 사용될 화면의 디자인 목업 URL입니다. LLM이 디자인과 일치하는 이름, 주소 등의 콘텐츠를 생성하는 데 도움을 줍니다.</li>                    </ul>                    <p>Airbnb의 내부 코드 생성 도구인 Niobe CLI는 이 디렉티브를 인식하여, JSON 목 데이터 파일과 함께 해당 데이터를 로드하고 사용할 수 있는 타입 안전한 헬퍼 함수를 생성합니다. 예를 들어, Swift 환경에서는 <code>mockMixedStatusIndicators()</code> 함수를 통해 목 데이터를 쉽게 사용할 수 있죠. 수동으로 JSON 파일을 로드할 필요 없이 말이죠!</p>                    <div class="code-box">                        <code>// Swift 유닛 테스트에서 사용 예시let mockData = InboxSyncQuery.Data.mockMixedStatusIndicators()// JSON 수동 로딩 없이 바로 타입 안전한 목 사용</code>                    </div>                    <p>심지어 생성된 JSON 데이터를 개발자가 수동으로 수정해도 괜찮습니다. Niobe는 다음 번 생성 시 개발자의 수동 변경 사항을 덮어쓰지 않도록 보호하는 메커니즘을 가지고 있습니다.</p>                </div>            </div>                        <!-- 본문 섹션 3 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">💡</span>                    LLM은 어떻게 '진짜 같은' Mock 데이터를 만들까요?                </h2>                <div class="section-content">                    <p>LLM이 데모에 사용할 만큼 현실적인 데이터를 생성하는 핵심 비결은 바로 풍부한 컨텍스트입니다. Niobe는 다음 정보를 LLM에 전달하여 고품질 목 데이터 생성을 유도합니다.</p>                    <ul class="bullet-list">                        <li><strong>쿼리/프래그먼트 정의</strong>: <code>@generateMock</code>이 붙은 대상과 그 의존성 정보.</li>                        <li><strong>GraphQL 스키마 서브셋</strong>: 전체 스키마가 아닌, 쿼리에 필요한 부분만 잘라내 전달하여 LLM의 컨텍스트 윈도우 부담을 줄입니다. 스키마 내 인라인 주석(문서)도 포함됩니다.</li>                        <li><strong>디자인 스냅샷 URL</strong>: <code>designURL</code>로 지정된 디자인 목업 이미지의 스냅샷 URL을 LLM에 제공하여 디자인과 시각적으로 일치하는 데이터를 만들도록 돕습니다.</li>                        <li><strong><code>hints</code></strong>: 개발자가 원하는 특정 시나리오를 지시합니다.</li>                        <li><strong>플랫폼 정보</strong>: "iOS", "Android", "Web" 등 플랫폼별 스타일 고려.</li>                        <li><strong>Airbnb 내부 이미지 URL 목록</strong>: LLM이 없는 이미지를 환각하지 않도록 실제 사용 가능한 이미지 URL 목록과 설명을 제공합니다.</li>                    </ul>                    <p>이 모든 정보는 Gemini 2.5 Pro 모델에 최적화된 프롬프트로 통합됩니다. 1백만 토큰 컨텍스트 윈도우를 가진 Gemini 2.5 Pro는 이 풍부한 컨텍스트를 바탕으로 매우 사실적인 JSON 목 데이터를 생성해 냅니다. 그 결과는 마치 실제 프로덕션 데이터를 보는 것과 같을 정도입니다.</p>                    <p>하지만 단순히 LLM이 생성했다고 끝이 아닙니다. Niobe는 LLM이 생성한 목 JSON 응답을 <code>graphql</code> NPM 패키지의 <code>graphqlSync</code> 함수로 <strong>엄격하게 검증</strong>합니다. 만약 LLM이 유효하지 않은 enum 값을 생성하거나 필수 필드를 누락하는 등 오류를 일으키면, Niobe는 이 오류를 LLM에 다시 피드백하여 <strong>스스로 데이터를 수정</strong>하도록 합니다. 이 '셀프 힐링' 메커니즘은 LLM의 환각을 방지하고, 최종적으로 생성되는 목 데이터의 타입 안전성을 강력하게 보장하는 핵심 단계입니다.</p>                    <div class="stage-grid">                        <div class="stage-card">                            <div class="stage-number">1</div>                            <div class="stage-name">컨텍스트 취합</div>                            <div class="stage-desc">쿼리 정의, 스키마, 디자인, 힌트 등 LLM에 전달</div>                        </div>                        <div class="stage-card">                            <div class="stage-number">2</div>                            <div class="stage-name">LLM 생성</div>                            <div class="stage-desc">Gemini 2.5 Pro가 JSON 목 데이터 생성</div>                        </div>                        <div class="stage-card">                            <div class="stage-number">3</div>                            <div class="stage-name">GraphQL 검증</div>                            <div class="stage-desc"><code>graphqlSync</code>로 타입 유효성 검사</div>                        </div>                        <div class="stage-card">                            <div class="stage-number">4</div>                            <div class="stage-name">오류 보정 & 저장</div>                            <div class="stage-desc">오류 시 LLM에 피드백, 유효하면 JSON 파일로 저장</div>                        </div>                    </div>                </div>            </div>                        <!-- 본문 섹션 4 (선택적) -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🚀</span>                    서버 구현 기다릴 필요 없이, 나만의 Mock으로 개발하자!                </h2>                <div class="section-content">                    <p><code>@generateMock</code>으로 현실적인 데이터를 만들었다면, 이제 이 데이터를 활용해 서버 개발과 무관하게 클라이언트 개발을 진행할 차례입니다. <code>@respondWithMock</code> 디렉티브가 바로 이 역할을 합니다.</p>                    <div class="code-box">                        <code>query MyFeatureQuery @generateMock(id: "feature_data") @respondWithMock {  myNewFeature {    id    title    description  }}</code>                    </div>                    <p>이 디렉티브가 존재하면, Niobe가 생성하는 코드에는 추가적인 메타데이터가 포함됩니다. 런타임에 GraphQL 클라이언트는 이 메타데이터를 보고 서버에서 데이터를 요청하는 대신, <code>@generateMock</code>으로 생성된 로컬 목 데이터를 반환하게 됩니다. 클라이언트 엔지니어는 더 이상 서버 구현을 기다릴 필요 없이, 완전히 독립적으로 기능을 개발하고 UI를 테스트할 수 있게 되는 것이죠.</p>                    <p>더 강력한 점은 <code>@respondWithMock</code>을 <strong>개별 필드에 적용</strong>할 수도 있다는 것입니다. 쿼리 전체가 아닌 특정 필드에 이 디렉티브를 사용하면, GraphQL 클라이언트는 해당 필드를 제외한 나머지 데이터는 서버에서 가져오고, <code>@respondWithMock</code>이 붙은 필드에는 로컬 목 데이터를 주입하여 마치 하나의 응답처럼 보여줍니다. 이를 통해 기존 쿼리에 새로 추가된 (아직 구현되지 않은) 필드에 대해서만 목 데이터를 사용하여, 프로덕션 데이터와 목 데이터를 하이브리드로 활용하는 유연한 개발이 가능해집니다.</p>                    <div class="code-box">                        <code>query MyDetailQuery($useMock: Boolean!) {  item(id: "123") {    name    status @respondWithMock(id: "status_mock") @include(if: $useMock)    description  }}</code>                    </div>                    <p>이렇게 조건부로 목 데이터를 사용할 수도 있어, 다양한 시나리오에 맞춰 유연하게 Mock을 활용할 수 있습니다.</p>                </div>            </div>                        <!-- 본문 섹션 5 (선택적) -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🔄</span>                    쿼리 변경되어도 Mock은 항상 최신 상태로 유지!                </h2>                <div class="section-content">                    <p>마지막으로 해결해야 할 과제는 쿼리가 시간이 지남에 따라 진화할 때 목 데이터를 항상 최신 상태로 유지하는 것이었습니다. Niobe는 이 문제를 지능적으로 관리합니다.</p>                    <p>목 데이터가 담긴 각 JSON 파일에는 두 가지 핵심 해시 값이 임베딩됩니다:</p>                    <ul class="bullet-list">                        <li>목업 대상 클라이언트 엔티티(GraphQL 쿼리 문서)의 해시</li>                        <li><code>@generateMock</code> 디렉티브 입력 인수의 해시</li>                    </ul>                    <p>코드 생성이 실행될 때마다, Niobe는 기존 목 데이터의 해시 값과 현재 GraphQL 문서 기반의 해시 값을 비교합니다. 해시 값이 일치하면 해당 목 데이터는 건너뛰지만, 해시 값이 변경되면 Niobe는 기존 목 데이터를 LLM에 전달되는 컨텍스트에 포함하고, 변경된 내용(Diff)을 집중적으로 수정하도록 지시하여 지능적으로 업데이트합니다.</p>                    <p>이 과정에서 중요한 점은, 개발자가 수동으로 수정한 부분이거나 변경되지 않은 유효한 필드에 대해서는 Niobe가 <strong>불필요한 수정을 피한다</strong>는 것입니다. LLM에게 쿼리에서 변경된 부분의 Diff를 명확히 알려줌으로써, 무관한 필드를 건드리지 않도록 프롬프트를 세밀하게 조정했죠. 이는 기존 테스트를 깨뜨리거나 개발자의 수동 노력을 무효화하는 것을 방지합니다.</p>                    <p>결과적으로 Airbnb는 iOS, Android, Web에서 수개월간 <strong>700개 이상</strong>의 Mock 데이터를 <code>@generateMock</code>을 통해 생성하고 병합했으며, 엔지니어들은 "로컬 개발 속도가 상당히 빨라졌고, 로컬 데이터로 작업하는 것이 훨씬 즐거워졌다"는 긍정적인 피드백을 주었습니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">MOCKS GENERATED</div>                            <div class="metric-value">700+</div>                            <div class="metric-desc">iOS, Android, Web에서 수개월간 생성</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">ENGINEER FEEDBACK</div>                            <div class="metric-value">긍정적</div>                            <div class="metric-desc">생산성 & 개발 만족도 향상</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">FUTURE SCOPE</div>                            <div class="metric-value">Backend</div>                            <div class="metric-desc">백엔드 서비스 지원 예정</div>                        </div>                    </div>                    <p>각 클라이언트 코드베이스에는 목 버전 해시가 항상 최신 상태인지 확인하는 자동화된 체크도 포함되어 있습니다. 이를 통해 쿼리가 진화해도 모든 생성된 목 데이터는 항상 싱크를 유지하도록 강제됩니다. 엔지니어들은 검증 실패 시 단순히 코드 생성을 다시 실행하기만 하면 됩니다. 수동 업데이트는 전혀 필요 없습니다.</p>                </div>            </div>                        <!-- 본문 섹션 6 (선택적, 초대형 기사만) -->                        <!-- CTA -->            <div class="cta-box">                <h3>실전 적용 인사이트</h3>                <p>Airbnb의 <code>@generateMock</code>은 단순한 도구가 아니라 <strong>개발 흐름의 재설계</strong>입니다. LLM을 GraphQL 인프라 내부에 통합하여 타입 안전성을 보장하고, Directive만으로 Mock 생성·응답·싱크를 자동화했죠. 수개월간 700개 이상의 Mock이 생성되며 검증되었습니다.</p>                <a href="https://medium.com/airbnb-engineering/graphql-data-mocking-at-scale-with-llms-and-generatemock-30b380f12bd6?source=rss----53c7c27702d5---4" class="cta-button" target="_blank">원문 읽기 →</a>            </div>        </div>                <!-- 푸터 -->        <div class="footer">            <p><strong>핵심 요약</strong>: Airbnb는 LLM(Gemini 2.5 Pro)과 새로운 GraphQL 디렉티브(<code>@generateMock</code>, <code>@respondWithMock</code>)를 활용해 GraphQL Mock 데이터의 생성, 관리, 동기화를 자동화하여 개발 생산성을 크게 높였습니다.</p>            <p>출처: <a href="https://medium.com/airbnb-engineering/graphql-data-mocking-at-scale-with-llms-and-generatemock-30b380f12bd6?source=rss----53c7c27702d5---4" target="_blank">The Airbnb Tech Blog의 "GraphQL Data Mocking at Scale with LLMs and @generateMock"</a></p>        </div>    </div></body></html>